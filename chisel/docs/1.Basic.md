# Chisel学习笔记

## Chisel类型和常量
chisel提供了三种数据类型来描述连接，组合逻辑电路和寄存器： Bits， Uint，Sint（二进制补码）。
* Bits(8.W) 表示8位宽的bits信号
* UInt(8.W) 表示8位宽的无符号整数
* SInt(8.W) 表示8位宽的有符号整数

位宽采用: 数字.W的形式表示，格式为n.W其中W要大写。
* Bits(8.W)表示8bits位宽。

常量采用: 数字.符号的形式表示，格式为n.U或S，其中U或S要大写。
* 0.U 定义一个无符号常量值为0
* -3.S 定义一个有符号常量值为-3

常量的宽度也可定义
* 3.U(4.W) 定义一个无符号4bits位宽的常量值为3

注意：
如果定义了个带位宽的常量忘记.W则可能会被解释为bit位，比如：
1.U(32) 会被解释为该常量的第32bit的取值。多数情况下chisel会自动推断常量的位宽。

其他进制的表示：（注意格式为字符串.符号）
* "hff".U         十六进制的0xff
* "o377".U        八进制0xff
* "b1111_1111".U  二进制的0xff， 下划线会为便于阅读，chisel会自动处理

字符可以用作常量，例如： `val aChar = 'A'.U`

Bool类型
* Bool()
* true.B
* false.B

## 组合逻辑电路
chisel使用bool代数运算符来描述组合逻辑电路。比如：
* val logic = (a & b) | c
* val and = a & b 按位与
* val or = a | b  按位或
* val xor = a ^ b 按位异或
* val not = ~a    按位取反

算术运算
* val add = a + b 加
* val sub = a - b 减
* val neg = -a    负值
* val mul = a * b 乘
* val div = a / b 除
* val mod = a % b 取余

该操作结果的位宽是加法和减法操作数的最大位宽，对于乘法则是两个宽度的总和，对于除法和取余操作通常是分子的宽度。

Signal也可以被定义成某种类型的wire。可以使用:=为wire赋值。

```
val w = Wire(UInt())
w := a & b
```

单独bit可以按照这样提取，比如：`val sign = x(31)`

多bits可以按照结束到起始提取，比如： `val lowByte = largeWord(7, 0)`

bits的可以使用##进行拼接，比如： `val word = highByte ## lowByte`

下面是chisel支持的操作符的完整列表：

| 操作 | 描述 | 数据类型 |
|-------|-------|-------|
| * / % | 乘法，除法，取余 | UInt，SInt |
| + - | 加法，减法 | UInt，SInt |
| === =/= | 相等，不相等 | UInt，SInt， Bool类型返回值 |
| > >= < <= | 大于，大于等于，小于，小于等于 | UInt，SInt， Bool类型返回值 |
| << >> |  左移，右移 | UInt，SInt |
| ~ | NOT | UInt，SInt， Bool |
| & \| ^ | AND OR XOR | UInt，SInt， Bool |
| ！ | 逻辑NOT | Bool |
| && \|\| | 逻辑AND，OR | Bool |

Chisel提供了一些api多信号进行操作
| Function | 描述 | 数据类型 |
|-------|-------|-------|
| v.andR v.orR v.xorR | AND,OR,XOR还原 | UInt, SInt, Bool类型返回值 |
| v(n) | 提取单个bit | UInt, SInt |
| v(end, start) | 提取bits域 | UInt, SInt |
| Fill(n, v)| bitstring复制n次| UInt, SInt |
| a ## b | bitfiled拼接| UInt, SInt |
| Cat(a, b, ....) | bitfiled拼接 | UInt, SInt |

## 寄存器
Chisel提供了一个寄存器，它是一组D触发器。该寄存器隐式连接到一个全局时钟，并在上升沿更新。
当寄存器声明时提供初始化值时，他使用全局复位信号连接到同步复位。

`val reg = RegInit(0.U(8.W))`

定义了一个8bits位宽初始值为0的寄存器。

通过:=更新运算符，将输入连接到寄存器，寄存器的输出在表达式中只需要使用名称即可

`reg := d` 更新寄存器的输入(需要手动绑定输入d)

`val q = reg` 寄存器的输出

寄存器也可以在定义时连接到其输入

`val netReg = RegNext(d)`（自动绑定输入d）

![chisel-reg](images/chisel-reg.png)

上图为chisel寄存器定义的电路，其中包含一个时钟，一个同步复位到0.U，输入d和输出q。
全局时钟和复位是隐式连接到每一个定义的寄存器。

寄存器还可以在定义时与其输入和一个常量连接作为初始值

`val bothReg = RegNext(d, 0.U)`  （推荐寄存器名称后加Reg以表示寄存器）

RegNext是RegInit的一层封装，将输入信号和默认值通过一个函数创建。

ps：相比较chise和amaranth，我更推荐学习amaranth

## 计数器
定义一个10个时钟周期的计数器
```
val cntReg = RegInit(0.U(8.W))

cntReg := Mux(cntReg === 9.U, 0.U, cntReg + 1)
```

## Bundle和Vec
Bundle是将不同类型的信号组合在一起，Ves是将相同类型的信号组合在一起，并可任意嵌套。

Bundle举例：
```
class Channel() extends Bundle {
    val data = UInt(32.W)
    val vaild = Bool()
}

val ch = Wire(new Channel())
ch.data = 123.U
ch.vaild = true.B

val b = ch.vaild
```

Vec举例:
```
val v = Wire(Vec(3, UInit(4.W)))
```

单个元素通过(索引)访问。包裹在Wire中的vec是一个多路选择器

```
v(0) := 1.U
v(1) := 3.U
v(3) := 5.U

val index = 1.U(2.W) 定义个2bits位宽的常量index值为1
val a = v(index)     访问向量v的index组信号
```

这是使用Vec的另一个例子
![chisel-reg](images/chisel-vec.png)
```
val m = Wire(Vec(3, UInt(8.W)))
m(0) := x
m(1) := y
m(2) := z

val muxOut = m(select)
```

类似于使用WireDefault，可以使用VecInit设置Vec的默认值。
```
val defVec = VecInit(1.U(3W), 2.U, 3.U) 自动推导位宽，初始值为1,2,3

when(cond) {
    defVec(0) := 4.U
    defVec(1) := 5.U
    defVec(2) := 6.U
}

val vecOut = defVec(sel)
```

不仅可以为Vec输入设置初始常量，还可以将Wire通过VecInit连接到Vec的输入。
```
val defVecSig = VecInit(d, e, f)
val vecOutSig = defVecSig(sel)
```

寄存器Vec
还可以将Vec包装到寄存器中，以定义一个寄存器数组。
```
val vReg = Reg(Vec(3, UInt(8.W))) 定义一个无符号8bits位宽长度为3的寄存器数组

val dout = vReg(rdIdx)
vReg(wrIdx) := din
```

以下示例定义了一个处理器的寄存器文件，32个寄存器，每个寄存器32bits位宽，类似于经典的32位RISC-V

```
val registerFile = Reg(Vec(32, UInt(32.W)))
```

该寄存器文件的一个元素通过索引访问，并被用作普通寄存器。
```
registerFile(index) := dIn # 更新索引中的寄存器
val dOut = registerFile(index) # 输出索引到的寄存器值
```

寄存器vec也可以被初始化。这就是寄存器被重置时的值。要初始化寄存器文件，我们使用带有重置常量的VecInit，并将其封装在RegInit中。
```
val initReg = RegInit(VecInit(0.U(3.W), 1.U, 2.U))
val resetVal = initReg(sel)
initReg(0) := d
initReg(1) := e
initReg(2) := f
```

如果寄存器Vec元素较多，且要重置为相同的值可以用Seq.fill函数去填充。
```
val resetRegFile = RegInit(VecInit(Seq.fill(32)(0.U(32.W)))) # 32个寄存器，初始值都为0
val rdRegFile = resetRegFile(sel)
```

组合Bundle和Vec
可以自由地混合Bundle和Vec。当使用Boundle类型创建向量时，需要传递一个向量字段的原型。
```
val vecBundle = Wire(Vec(8, new Channel())) # 8个相同的类型的Boundle
```

Boundle也可以包含一个Vec
```
class BundleVec extend Bundle {
    val filed = UInt(8.W)
    val vector = Vec(4, UInt(8.W))
}
```

当需要对一个bundle类型的寄存器设置复位值时，首先创建该bundle类的wire，按需设置各个字段，然后将这个bundle传递给RegInit
```
val initVal = Wire(new Channel())

initVal.data := 0.U
initVal.vaild := false.B

val channelReg = RegInit(initVal)
```

PS： amaranth也有类似抽象，且更加丰富。

可能出现的语法使用错误：
```
val assignWord = Wire(UInt(16.W))

assignWord(7, 0) := lowByte
assignWord(15, 8) := highByte
```
boundle可以解决上述问题
```
val assignWord = Wire(UInt(16.W))

class Split extends Bundle {
    val high = UInt(8.W)
    val low = UInt(8.W)
}

val split = Wire(new Split())
split.low := lowByte
split.high := highByte

assignWord := split.asUInt
```
这种解决方案的缺点是需要知道那些顺序的Bundle字段被和并未一个bit vecs。另一种选择是按Bool向量来单独赋值，然后将其转换为UInt。

## Wire，Reg，IO
UInt,SInt,Bits是Chisel的类型，他们本身并不代表硬件。只是有他们封装在Wire，Reg，IO中，才会生成硬件。Wire代表组合逻辑，Reg代表寄存器，而IO代表模块连接的端口。任何Chisel类型都可以封装成Wire，Reg，IO。

```
val number = Wire(UInt())
val reg = Reg(SInt())
```
使用Chisel运算符:=将Value或表达式assign给Wire，Reg或IO。
```
number := 10.U
reg:= value - 3.U
```

注意：
运算符=与:=之间存在区别，当创建一个硬件对象使用=，而给现有硬件对象赋值或重新赋值时，使用:=.

创建Wire时定义一个默认值是最佳实践。
```
val number = WireDefault(10.U(4.W))
```

尽管chisel会自动推断位宽，但还是建议在创建硬件对象时指定位宽，大多数情况下，在复位时将寄存器设置为已知的初始值也是个好习惯。

```
val reg = RegInit(0.S(8.W))
```

## Chisel生成硬件
每个组建的创建都增加了硬件;每个赋值语句都会生成门和/或触发器。从技术上讲，当Chisel执行你的代码时，它作为Scala程序运行，通过执行Chisel语句，它收集硬件组建并连接这些节点。这个硬件节点网络就是硬件，Chisel可以将其输出为ASIC或FPGA合成Verilog代码，也可通过Chisel的tester进行测试。

## 练习
```
import chisel3._

class Hello extends Module {
    val io = IO(new Bundle {
        val sw = Input(UInt(2.W))
        val led = Output(UInt(1.W))
    })

    when(io.sw === 0.U) {
        io.led := 1.U
    }.otherwise {
        io.led := 0.U
    }
}

object Hello extends APP {
    (new chisel3.stahe.ChiselStage).emitVerilog(new Hello())
}

```
